(async () => {
  const handle = "YouTwitterHere";
  const deleteConfirmSelector = '[data-testid="confirmationSheetConfirm"]';
  const repostButtonSelector = 'button[data-testid="unretweet"]';

  let pinnedPostId = null;
  const deletedPosts = new Set();

  const sleep = (seconds) =>
    new Promise((resolve) => setTimeout(resolve, seconds * 1000));

  const waitForElement = (checkFn, timeout = 3000) =>
    new Promise((resolve, reject) => {
      const start = Date.now();
      const timer = setInterval(() => {
        const el = checkFn();
        if (el) {
          clearInterval(timer);
          resolve(el);
        } else if (Date.now() - start > timeout) {
          clearInterval(timer);
          reject("Timeout waiting for element");
        }
      }, 100);
    });

  const getPinnedPostId = () => {
    const pinned = document.querySelector('[aria-label="Pinned Tweet"]');
    if (pinned) {
      const link = pinned.querySelector('a[href*="/status/"]');
      if (link) {
        pinnedPostId = link.href.split("/status/")[1];
      }
    }
  };

  const getMyTweets = () => {
    return Array.from(document.querySelectorAll('article[data-testid="tweet"]')).filter((article) => {
      const link = article.querySelector(`a[href*="/${handle}"]`);
      const statusLink = article.querySelector('a[href*="/status/"]');
      if (!link || !statusLink) return false;

      const tweetId = statusLink.href.split("/status/")[1];
      if (tweetId === pinnedPostId || deletedPosts.has(tweetId)) return false;

      return true;
    });
  };

  const undoRepostFlow = async (article) => {
    try {
      const repostBtn = article.querySelector(repostButtonSelector);
      if (!repostBtn) return false;

      repostBtn.click();
      await sleep(0.5);

      const undoOption = document.evaluate(
        "//span[contains(text(), 'Undo repost')]",
        document,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      ).singleNodeValue;

      if (undoOption) {
        undoOption.click();
        await sleep(0.5);
        console.log(`ðŸ” Un-reposted`);
        return true;
      }
    } catch (err) {
      console.warn(`â›” Repost skip: ${err}`);
    }
    return false;
  };

  const clickDeleteFlow = async (article) => {
    try {
      const tweetId = article.querySelector('a[href*="/status/"]').href.split("/status/")[1];

      const caretBtn = article.querySelector('[data-testid="caret"]');
      if (!caretBtn) return;

      caretBtn.click();

      let deleteBtn;
      try {
        deleteBtn = await waitForElement(() => {
          return document.evaluate(
            "//span[text()='Delete']",
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
          ).singleNodeValue;
        });
      } catch (err) {
        // No Delete found â†’ likely a repost
        console.log(`â†©ï¸ No delete option for ${tweetId}, trying un-repost...`);
        const success = await undoRepostFlow(article);
        if (success) deletedPosts.add(tweetId);
        return;
      }

      deleteBtn.click();

      const confirmBtn = await waitForElement(() => {
        return document.querySelector(deleteConfirmSelector);
      });

      confirmBtn.click();

      deletedPosts.add(tweetId);
      console.log(`âœ… Deleted: ${tweetId}`);
    } catch (err) {
      console.warn(`â›” Delete skip: ${err}`);
    }
  };

  const processBatch = async () => {
    let didSomething = false;

    // Handle deletions (with fallback to un-repost)
    const myTweets = getMyTweets();
    if (myTweets.length > 0) {
      for (const tweet of myTweets) {
        await clickDeleteFlow(tweet);
        didSomething = true;
        await sleep(0.5);
      }
    }

    // Handle stray un-repost buttons if any remain
    const repostButtons = Array.from(document.querySelectorAll(repostButtonSelector));
    if (repostButtons.length > 0) {
      for (const button of repostButtons) {
        await undoRepostFlow(button.closest('article[data-testid="tweet"]'));
        didSomething = true;
        await sleep(0.5);
      }
    }

    return didSomething;
  };

  const scrollAndExecute = async () => {
    console.log("ðŸš€ Starting deletion & un-repost cycle...");
    getPinnedPostId();

    let keepGoing = true;
    while (keepGoing) {
      keepGoing = await processBatch();
      window.scrollBy(0, window.innerHeight);
      await sleep(1.5);
    }

    console.log("âœ… All deletions and un-reposts complete.");
  };

  await scrollAndExecute();
})();
